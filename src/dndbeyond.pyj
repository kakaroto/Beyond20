from utils import replaceRolls, alertQuickSettings, isListEqual
from settings import getStoredSettings, mergeSettings, character_settings, WhisperType, RollType, CriticalRules
from dndbeyond_dice import dndbeyondDiceRoller
from elementmaker import E
import uuid
import re

ability_abbreviations = {"Strength": "STR",
                         "Dexterity": "DEX",
                         "Constitution": "CON",
                         "Intelligence": "INT",
                         "Wisdom": "WIS",
                         "Charisma": "CHA"}

skill_abilities = {"Acrobatics": "DEX",
                   "Animal Handling": "WIS",
                   "Arcana": "INT",
                   "Athletics": "STR",
                   "Deception": "CHA",
                   "History": "INT",
                   "Insight": "WIS",
                   "Intimidation": "CHA",
                   "Investigation": "INT",
                   "Medicine": "WIS",
                   "Nature": "INT",
                   "Perception": "WIS",
                   "Performance": "CHA",
                   "Persuasion": "CHA",
                   "Religion": "INT",
                   "Sleight of Hand": "DEX",
                   "Stealth": "DEX",
                   "Survival": "WIS"}


class Spell:
    def __init__(self, body, character, type="page"):
        self._character = character
        if type == "page":
            title_selector = ".page-title"
            statblock_selector = ".ddb-statblock"
            description_selector = ".spell-details .more-info-content"
            casting_time_label = "casting-time"
            range_area_label = "range-area"
        elif type == "tooltip":
            title_selector = ".tooltip-header-text"
            statblock_selector = ".tooltip-body-statblock"
            description_selector = ".tooltip-body-description-text"
            casting_time_label = "castingtime"
            range_area_label = "range"

        def get_statblock(label):
            return body.find(statblock_selector + "-item-" + label + " " + statblock_selector + "-item-value").text().trim()

        self.spell_name = body.find(title_selector).text().trim()
        level = get_statblock("level")
        school = get_statblock("school")
        self.casting_time = get_statblock(casting_time_label)
        self.range_area = get_statblock(range_area_label)
        self.components = get_statblock("components")
        self.duration = get_statblock("duration")
        self.description = body.find(description_selector).text().trim()
        self.preview = "https://www.dndbeyond.com/content/1-0-851-0/skins/waterdeep/images/spell-schools/35/" + school.toLowerCase() + ".png"
        if level == "Cantrip":
            self.level_school = school + " " + level
        else:
            self.level_school = level + " Level " + school
        if self.duration.startsWith("Concentration"):
            self.concentration = True
            self.duration = self.duration.replace("Concentration", "").trim()
        else:
            self.concentration = False
        self.ritual = (body.find(statblock_selector + "-item-casting-time .i-ritual").length > 0)
        if self.components[-1] == "*":
            materials = body.find(description_selector + " .components-blurb").text().trim()
            material_len = len(materials)
            self.description = self.description[:-material_len].trim()
            self.components = self.components[:-2] + materials[4:]
        aoe = body.find(statblock_selector + "-item-range-area .aoe-size").text().trim()
        if aoe != "":
            aoe_len = len(aoe)
            self.range_area = self.range_area[:-aoe_len].trim() + " " + aoe.trim()

    def display(self):
        sendRoll(self._character, "spell-card", 0, {
            "name": self.spell_name,
            "preview": self.preview,
            "level-school": self.level_school,
            "range": self.range_area,
            "concentration": self.concentration,
            "duration": self.duration,
            "casting-time": self.casting_time,
            "components": self.components,
            "ritual": self.ritual,
            "description": self.description
        })


class CharacterBase:
    def __init__(self, _type, global_settings):
        self._name = None
        self._type = _type
        self._settings = None
        self.setGlobalSettings(global_settings)

    def type(self):
        return self._type

    def getSetting(self, key, default_value="", settings=None):
        if settings is None:
            settings = self._settings
        if settings? and settings[key]?:
            return settings[key]
        return default_value

    def getGlobalSetting(self, key, default_value=""):
        return self.getSetting(key, default_value, self._global_settings)

    def setGlobalSettings(self, new_settings):
        self._global_settings = new_settings
        dndbeyondDiceRoller.setSettings(new_settings)
        updateRollTypeButtonClasses(self)

    def getDict(self):
        return {"name": self._name, "type": self._type}

class Character(CharacterBase):
    def __init__(self, global_settings):
        CharacterBase.__init__(self, "Character", global_settings)
        self._abilities = []
        self._name = None
        self._avatar = None
        self._id = None
        self._race = None
        self._level = None
        self._classes = None
        self._ac = None
        self._speed = None
        self._proficiency = None
        self._hp = 0
        self._max_hp = 0
        self._temp_hp = 0
        self._class_features = []
        self._racial_traits = []
        self._feats = []
        self._actions = []
        self._to_hit_cache = {}
        self._conditions = []
        self._exhaustion = 0

    def updateInfo(self):
        self._id = $("#character-sheet-target").attr("data-character-id")
        if self._settings is None:
            self.updateSettings()

        # Static values that need an edit to change
        if self._name is None:
            self._name = $(".ct-character-tidbits__name").text()
            # This can happen when you reload the page
            if self._name == "":
                self._name = None
        if self._avatar is None:
            avatar = $(".ct-character-tidbits__avatar").css('background-image')
            if avatar and avatar.startsWith("url("):
                self._avatar = avatar.slice(5, -2)
        if self._race is None:
            self._race = $(".ct-character-tidbits__race").text()
            if self._race == "":
                self._race = None
        if self._classes is None:
            classes = $(".ct-character-tidbits__classes")
            if classes.length > 0:
                classes = classes.text().split(" / ")
                self._classes = {}
                for class_ in classes:
                    parts = class_.split(" ")
                    name = str.join(" ", parts[:-1])
                    level = parts[-1]
                    self._classes[name] = level
        if self._level is None:
            level = $(".ct-character-tidbits__xp-level")
            xp = $(".ct-character-tidbits__xp-bar .ct-xp-bar__item--cur .ct-xp-bar__label")
            if level.length > 0:
                self._level = level.text().replace("Level ", "")
            elif xp.length > 0:
                self._level = xp.text().replace("LVL ", "")
        if self._proficiency is None:
            self._proficiency = $(".ct-proficiency-bonus-box__value").text()
            if self._proficiency == "":
                self._proficiency = $(".ct-combat-mobile__extra--proficiency .ct-combat-mobile__extra-value").text()
                if self._proficiency == "":
                    self._proficiency = None
        if Object.keys(self._to_hit_cache).length == 0:
            items = $(".ct-combat-attack--item .ct-item-name")
            for item in items:
                item_name = item.textContent
                to_hit = findToHit(item_name, ".ct-combat-attack--item", ".ct-item-name", ".ct-combat-attack__tohit")
                #console.log("Caching to hit for ", item_name, " : ", to_hit)
                self._to_hit_cache[item_name] = to_hit

        # Values that could change/get overriden dynamically
        ac = $(".ct-armor-class-box__value").text()
        if ac == "":
            ac = $(".ct-combat-mobile__extra--ac .ct-combat-mobile__extra-value").text()
        if ac != "":
            self._ac = ac
        speed = $(".ct-speed-box__box-value .ct-distance-number__number").text()
        if speed == "":
            speed = $(".ct-combat-mobile__extra--speed .ct-combat-mobile__extra-value .ct-distance-number__number").text()
        if speed != "":
            self._speed = speed
        abilities = $(".ct-quick-info__ability")
        if abilities.length == 0:
            abilities = $(".ct-main-mobile__ability")
        if abilities.length == 0:
            abilities = $(".ct-main-tablet__ability")

        if abilities.length > 0:
            self._abilities = []
        for ability in abilities:
            name = $(ability).find(".ct-ability-summary__heading .ct-ability-summary__label").text()
            abbr = $(ability).find(".ct-ability-summary__heading .ct-ability-summary__abbr").text().toUpperCase()
            modifier = $(ability).find(".ct-ability-summary__primary .ct-signed-number").text()
            value = $(ability).find(".ct-ability-summary__secondary").text()
            if modifier == "":
                modifier = $(ability).find(".ct-ability-summary__secondary .ct-signed-number").text()
                value = $(ability).find(".ct-ability-summary__primary").text()
            self._abilities.append([name, abbr, value, modifier].as_array())
        if self._settings?:
            self.updateHP()
        self.updateFeatures()

    def updateHP(self):
        health_pane = $(".ct-health-manager")
        if health_pane.length > 0:
            hp = int(health_pane.find(".ct-health-manager__health-item--cur .ct-health-manager__health-item-value").text())
            max_hp = int(health_pane.find(".ct-health-manager__health-item--max .ct-health-manager__health-item-value .ct-health-manager__health-max-current").text())
            temp_hp = int(health_pane.find(".ct-health-manager__health-item--temp .ct-health-manager__health-item-value input").val())
        else:
            hp = max_hp = temp_hp = None
            hp_items = $(".ct-health-summary__hp-group--primary .ct-health-summary__hp-item")
            for item in hp_items:
                label = $(item).find(".ct-health-summary__hp-item-label").text()
                if label == "Current":
                    # Make sure it's not an input being modified
                    number = $(item).find(".ct-health-summary__hp-item-content .ct-health-summary__hp-number")
                    if number.length > 0:
                        hp = int(number.text())
                elif label == "Max":
                    max_hp = int($(item).find(".ct-health-summary__hp-item-content .ct-health-summary__hp-number").text())
            temp_item = $(".ct-health-summary__hp-group--temp .ct-health-summary__hp-item--temp .ct-health-summary__hp-item-content")
            if temp_item.length > 0:
                # Can be hp-empty class instead
                number = temp_item.find(".ct-health-summary__hp-number").text()
                temp_hp = int(number) if number != "" else 0
            else:
                temp_hp = self._temp_hp

            mobile_hp = $(".ct-status-summary-mobile__hp-current")
            if mobile_hp.length > 0:
                hp = int(mobile_hp.text())
                max_hp = int($(".ct-status-summary-mobile__hp-max").text())
                has_temp = $(".ct-status-summary-mobile__hp.ct-status-summary-mobile__hp--has-temp")
                if has_temp.length > 0:
                    temp_hp = self._temp_hp
                else:
                    temp_hp = 0
                hp = hp - temp_hp
            if $(".ct-status-summary-mobile__deathsaves-group").length > 0 or \
                    $(".ct-health-summary__deathsaves").length > 0:
                # if we find death saving section, then it means the HP is 0
                hp = 0
                temp_hp = 0
                max_hp = self._max_hp
        if hp is not None and max_hp is not None and (self._hp != hp or self._max_hp != max_hp or self._temp_hp != temp_hp):
            self._hp = hp
            self._max_hp = max_hp
            self._temp_hp = temp_hp
            print("HP updated to : (" + hp + "+" + temp_hp + ")/" + max_hp)

            req = {"action": "hp-update", "character": self.getDict()}
            console.log("Sending message: ", req)
            chrome.runtime.sendMessage(req, def(resp): beyond20SendMessageFailure(self, resp);)

    def updateConditions(self, conditions=None, exhaustion_level=None):
        if conditions is None:
            conditions = list(self.getSetting("conditions", []))
        if exhaustion_level is None:
            exhaustion_level = self.getSetting("exhaustion-level", 0)
        self._conditions = conditions
        self._exhaustion = exhaustion_level
        #console.log("Updating conditions to : ", conditions, exhaustion_level)
        if self._settings ? and \
            (not isListEqual(self._conditions, self.getSetting("conditions", [])) or \
                self._exhaustion != self.getSetting("exhaustion-level", 0)):
            sendUpdate = def():
                req = {"action": "conditions-update", "character": self.getDict()}
                console.log("Sending message: ", req)
                chrome.runtime.sendMessage(req, def(resp): beyond20SendMessageFailure(self, resp);)
            self.mergeCharacterSettings({"conditions": self._conditions,
                                         "exhaustion-level": self._exhaustion}, sendUpdate)

    def featureDetailsToList(self, selector, name):
        features = $(selector).find(".ct-feature-snippet > .ct-feature-snippet__heading")
        feature_list = []
        for feat in features:
            feat_name = feat.childNodes[0].textContent.trim()
            feature_list.append(feat_name)
            options = $(feat).parent().find(".ct-feature-snippet__option > .ct-feature-snippet__heading")
            for option in options:
                option_name = option.childNodes[0].textContent.trim()
                feature_list.append(feat_name + ": " + option_name)

        #console.log(name, feature_list)
        return feature_list

    def updateFeatures(self):
        update = False
        class_detail = $(".ct-features .ct-classes-detail")
        if class_detail.length > 0:
            self._class_features = self.featureDetailsToList(class_detail, "Class Features")
            if not isListEqual(self._class_features, self.getSetting("class-features", [])):
                console.log("New class feature")
                update = True
        elif self.getSetting("class-features", None):
            self._class_features = list(self.getSetting("class-features", None))

        race_detail = $(".ct-features .ct-race-detail")
        if race_detail.length > 0:
            self._racial_traits = self.featureDetailsToList(race_detail, "Racial Traits")
            if not isListEqual(self._racial_traits, self.getSetting("racial-traits", [])):
                console.log("New race feature")
                update = True
        elif self.getSetting("racial-traits", None):
            self._racial_traits = list(self.getSetting("racial-traits", None))

        feats_detail = $(".ct-features .ct-feats-detail")
        if feats_detail.length > 0:
            self._feats = self.featureDetailsToList(feats_detail, "Feats")
            if not isListEqual(self._feats, self.getSetting("feats", [])):
                console.log("New Feats")
                update = True
        elif self.getSetting("feats", None):
            self._feats = list(self.getSetting("feats", None))

        actions_detail = $(".ct-actions-list .ct-actions-list__activatable")
        if actions_detail.length > 0:
            self._actions = self.featureDetailsToList(actions_detail, "Actions")
            if not isListEqual(self._actions, self.getSetting("actions", [])):
                console.log("New Actions")
                update = True
        elif self.getSetting("actions", None):
            self._actions = list(self.getSetting("actions", None))

        if self._settings? and update:
            self.mergeCharacterSettings({"class-features": self._class_features,
                                         "racial-traits": self._racial_traits,
                                         "feats": self._feats,
                                         "actions": self._actions})

    def hasClassFeature(self, name):
        return name in self._class_features
    def hasRacialTrait(self, name):
        return name in self._racial_traits
    def hasFeat(self, name):
        return name in self._feats
    def hasAction(self, name):
        return name in self._actions
    def getClassLevel(self, name):
        if name in self._classes:
            return self._classes[name]
        else:
            return 0

    def _cacheToHit(self, item_name, to_hit):
        self._to_hit_cache[item_name] = to_hit

    def _getToHitCache(self, item_name):
        if self._to_hit_cache[item_name] ?:
            return self._to_hit_cache[item_name]
        return None

    def mergeCharacterSettings(self, data, callback=None):
        cb = def(settings):
            self.updateSettings(settings)
            chrome.runtime.sendMessage({"action": "settings",
                                        "type": "character",
                                        "id": self._id,
                                        "settings": settings})
            if callback:
                callback(settings)
        mergeSettings(data, cb, "character-" + self._id, character_settings)

    def updateSettings(self, new_settings=None):
        if new_settings:
            self._settings = new_settings
        else:
            getStoredSettings(def(saved_settings):
                self.updateSettings(saved_settings)
                self.updateHP()
                self.updateFeatures()
                self.updateConditions()
            , "character-" + self._id, character_settings)

    def getDict(self):
        settings = {}
        # Make a copy of the settings but without the features since they are
        # already in the dict
        for key in self._settings:
            if key not in ["class-features", "racial-traits", "feats", "actions", "conditions", "exhaustion-level"]:
                settings[key] = self._settings[key]
        return {"name": self._name,
                "avatar": self._avatar,
                "id": self._id,
                "type": self.type(),
                "abilities": self._abilities.as_array(),
                "classes": self._classes,
                "level": self._level,
                "race": self._race,
                "ac": self._ac,
                "proficiency": self._proficiency,
                "speed": self._speed,
                "hp": self._hp,
                "max-hp": self._max_hp,
                "temp-hp": self._temp_hp,
                "exhaustion": self._exhaustion,
                "conditions": self._conditions.as_array(),
                "settings": settings,
                "class-features": self._class_features.as_array(),
                "racial-traits": self._racial_traits.as_array(),
                "feats": self._feats.as_array(),
                "actions": self._actions.as_array()}


class Monster(CharacterBase):
    def __init__(self, _type, base=None, global_settings=None):
        CharacterBase.__init__(self, _type, global_settings)
        if self.type() == "Monster":
            self._base = ".mon-stat-block"
        elif self.type() == "Creature":
            self._base = ".ct-creature-block"
        elif self.type() == "Vehicle" or self.type() == "Extra-Vehicle":
            self._base = ".vehicle-stat-block"
        else:
            self._base = ".mon-stat-block"
        if base:
            self._base = base
        self._stat_block = $(self._base)
        self._id = None
        self._name = None
        self._avatar = None
        self._meta = None
        self._attributes = {}
        self._ac = None
        self._hp = None
        self._hp_formula = None
        self._max_hp = 0
        self._temp_hp = 0
        self._speed = None
        self._abilities = []
        self._tidbits = {}
        self._saves = {}
        self._skills = {}
        self._spells = {}
        self._cr = None

    def parseStatBlock(self, stat_block=None):
        add_dice=self.getGlobalSetting('handle-stat-blocks', True)
        inject_descriptions=self.getGlobalSetting('subst-dndbeyond-stat-blocks', True)
        base = self._base
        if stat_block is None:
            stat_block = $(base)
        self._stat_block = stat_block
        if self.type() != "Creature" and self.type() != "Extra-Vehicle":
            $(".ct-beyond20-settings-button").remove()
            quick_settings = E.div(class_="ct-beyond20-settings-button", style="background-color: rgba(0, 0, 0, 0.1)",
                                    E.img(class_="ct-beyond20-settings", src=chrome.extension.getURL("images/icons/icon32.png"), style="vertical-align: top;"),
                                    E.span(class_="ct-beyond20-settings-button-label mon-stat-block__tidbit mon-stat-block__tidbit-label", style="font-size: 28px; margin: 5px;", "Beyond 20")
                            )
            stat_block.find(base + "__header").prepend(quick_settings)
            $(quick_settings).on('click', def(event): alertQuickSettings();)
        self._name = stat_block.find(base + "__name").text().trim()
        link = stat_block.find(base + "__name-link")
        if link.length > 0:
            self._id = link.attr("href").replace("/monsters/", "").replace("/vehicles/", "")
        else:
            self._id = self._name
        self._meta = stat_block.find(base + "__meta").text().trim()
        avatar = $(".details-aside .image a")
        if avatar.length > 0:
            self._avatar = avatar[0].href
        attributes = stat_block.find(base + "__attributes " + base + "__attribute")
        for attr in attributes:
            label = $(attr).find(base + "__attribute-label").text().trim()
            value = $(attr).find(base + "__attribute-value").text().trim()
            if value == "":
                value = $(attr).find(base + "__attribute-data").text().trim()
            if label == "Armor Class":
                self._ac = $(attr).find(base + "__attribute-data-value").text().trim()
            elif label == "Hit Points":
                self._hp = $(attr).find(base + "__attribute-data-value").text().trim()
                self._hp_formula = $(attr).find(base + "__attribute-data-extra").text().trim()[1:-1]
                cb = def():
                    self.rollHitPoints()
                if add_dice:
                    addIconButton(cb, $(attr).find(base + "__attribute-data-extra"))
            elif label == "Speed":
                self._speed = value
            self._attributes[label] = value

        abilities = stat_block.find(base + "__abilities")
        if abilities.length > 0:
            prefix = base + "__ability-"
            abilities = abilities.find("> div")
        else:
            abilities = stat_block.find(".ability-block > div")
            prefix = ".ability-block__"
        makeCB = def(a):
            return def():
                self.rollAbilityCheck(a)
        for ability in abilities:
            abbr = $(ability).find(prefix + "heading").text().toUpperCase()
            score = $(ability).find(prefix + "score").text()
            modifier = $(ability).find(prefix + "modifier").text()[1:-1]
            self._abilities.append([abbreviationToAbility(abbr), abbr, score, modifier].as_array())
            if add_dice:
                addIconButton(makeCB(abbr), ability, prepend=True)
                if abbr == "DEX":
                    roll_initiative = stat_block.find(base + "__beyond20-roll-initiative")
                    attributes = stat_block.find(base + "__attributes")
                    if attributes.length > 0:
                        attributes = attributes.eq(0)
                        if roll_initiative.length == 0:
                            initiative = $(E.div(class_=base[1:] + "__attribute " + base[1:] + "__beyond20-roll-initiative",
                                            E.span(class_=base[1:] + "__attribute-label", "Roll Initiative!"),
                                            E.span(class_=base[1:] + "__attribute-data",
                                                E.span(class_=base[1:] + "__attribute-data-value", "  " + modifier)
                                            )
                                        ))
                        else:
                            initiative = roll_initiative.eq(0)
                        attributes.append(initiative)
                        cb = def():
                                self.rollInitiative()
                        addIconButton(cb, initiative.find(base + "__attribute-data"))


        tidbits = stat_block.find(base + "__tidbits " + base + "__tidbit")
        for tidbit in tidbits:
            label = $(tidbit).find(base + "__tidbit-label").text()
            data = $(tidbit).find(base + "__tidbit-data")
            value = data.text().trim()
            if label == "Saving Throws":
                saves = value.split(", ")
                if add_dice:
                    data.html("")
                makeCB = def(a):
                    return def():
                        self.rollSavingThrow(a)
                for save in saves:
                    parts = save.split(" ")
                    abbr = parts[0]
                    mod = parts.slice(1).join(" ")
                    self._saves[abbr] = mod
                    if add_dice:
                        data.append(abbr + " " + mod)
                        addIconButton(makeCB(abbr), data, append=True)
                        if len(saves) > len(self._saves):
                            data.append(", ")
            elif label == "Skills":
                skills = value.split(", ")
                for skill in skills:
                    parts = skill.split(" ")
                    name = parts[0]
                    mod = parts.slice(1).join(" ")
                    self._skills[name] = mod
                if not add_dice:
                    continue
                makeCB = def(a):
                    return def():
                        self.rollSkillCheck(a)
                if self.type() == "Monster":
                    skills = data.find("> a")
                    for a in skills:
                        mon_skill = a.textContent
                        text = a.nextSibling
                        last = True
                        if text.textContent.endsWith(", "):
                            text.textContent = text.textContent[:-2]
                            last = False
                        addIconButton(makeCB(mon_skill), a.nextSibling)
                        if not last:
                            $(a.nextElementSibling).after(", ")
                else:
                    data.html("")
                    first = True
                    for skill in self._skills:
                        if not first:
                            data.append(", ")
                        first = False
                        data.append(skill + " " + self._skills[skill])
                        if add_dice:
                            addIconButton(makeCB(skill), data, append=True)

            elif label == "Challenge":
                self._cr = value.split(" ")[0]
            self._tidbits[label] = value
        self.lookForActions(stat_block, add_dice, inject_descriptions)
        if add_dice:
            self.lookForSpells(stat_block)
        #console.log("Done parsing stat block:", self)

    def rollHitPoints(self):
        sendRoll(self, "custom", self._hp_formula, {"name": "Hit Points",
                                                    "modifier": self._hp_formula})

    def rollAbilityCheck(self, abbr):
        for ability in self._abilities:
            if ability[1] == abbr:
                name, abbr, score, modifier = ability
                sendRoll(self, "ability", "1d20" + modifier, {"name" : name,
                                                              "ability": abbr,
                                                              "modifier": modifier,
                                                              "ability-score": score} )
                break

    def rollInitiative(self):
        for ability in self._abilities:
            if ability[1] == "DEX":
                modifier = ability[3]

                initiative = modifier
                if self.getGlobalSetting("initiative-tiebreaker", False):
                    tiebreaker = ability[2]

                    # Add tiebreaker as a decimal
                    initiative = float(initiative) + float(tiebreaker) / 100

                    # Render initiative as a string that begins with '+' or '-'
                    initiative = '+' + str(initiative) if initiative >= 0 else str(initiative)

                sendRoll(self, "initiative", "1d20" + initiative, {"initiative": initiative})
                break

    def rollSavingThrow(self, abbr):
        mod = self._saves[abbr]
        name = abbreviationToAbility(abbr)
        sendRoll(self, "saving-throw", "1d20" + mod, {"name" : name,
                                                      "ability": abbr,
                                                      "modifier": mod} )

    def rollSkillCheck(self, skill):
        modifier = self._skills[skill]
        ability = skillToAbility(skill)
        sendRoll(self, "skill", "1d20" + modifier, {"skill": skill,
                                                    "ability": ability,
                                                    "modifier": modifier})

    def parseAttackInfo(self, description):
        m = re.search("(Melee|Ranged)(?: Weapon| Spell)? Attack:.*?(\+[0-9]+) to hit.*?, (?:reach|ranged?) (.*?)(?:,.*?)?\.", description)
        if m:
            return (m.group(1), m.group(2), m.group(3))
        else:
            return None

    def parseHitInfo(self, description):
        damages = None
        save = None
        hit_idx = description.indexOf("Hit:")
        hit = description
        if hit_idx > 0:
            hit = description[hit_idx:]
        damage_regexp = "([\w]* )(?:([0-9]+))?(?: *\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)?)\)?)? ([\w ]+?) damage"
        damage_matches = re.finditer(damage_regexp, hit)
        damages = []
        damage_types = []
        for dmg in damage_matches:
            # Skip any damage that starts wit "DC" because of "DC 13 saving throw or take damage" which could match.
            # A lookbehind would be a simple solution here but rapydscript doesn't let me.
            # Also skip "target reduced to 0 hit points by this damage" from demon-grinder vehicle.
            if dmg.group(1) == "DC " or dmg.group(4) == "hit points by this":
                continue
            if dmg.group(3)?:
                damages.append(dmg.group(3))
            else:
                damages.append(dmg.group(2))
            damage_types.append(dmg.group(4))
        m = re.search("DC ([0-9]+) (.*?) saving throw", hit)
        if m:
            save = (m.group(2), m.group(1))
        else:
            m = re.search("escape DC ([0-9]+)", hit)
            if m:
                save = ("Escape", m.group(1))

        if damages.length == 0 and save is None:
            return None
        return (damages, damage_types, save)

    def buildAttackRoll(self, name, description):
        roll_properties = {"name": name,
                           "preview": self._avatar,
                           "attack-source": "monster-action",
                           "description": description}

        attackInfo = self.parseAttackInfo(description)
        #console.log("Attack info for ", name, attackInfo)
        if attackInfo:
            attack_type, to_hit, reach_range = attackInfo
            roll_properties["to-hit"] = to_hit
            roll_properties["attack-type"] = attack_type
            roll_properties["reach" if attack_type == "Melee" else "range"] = reach_range


        hitInfo = self.parseHitInfo(description)
        #console.log("Hit info for ", name, hitInfo)
        if hitInfo:
            # Can't use '(damages, damage_types, save) = hitInfo' because rapydscript flattens
            # the lists within the list and assigns the strings to each of the 3 vars instead of lists
            damages = hitInfo[0]
            damage_types = hitInfo[1]
            save = hitInfo[2]
            if len(damages) > 0:
                roll_properties["damages"] = damages.as_array()
                roll_properties["damage-types"] = damage_types.as_array()
                crits = damagesToCrits(self, damages, damage_types)
                crit_damages = []
                crit_damage_types = []
                for i, dmg in enumerate(crits):
                    if dmg != "":
                        crit_damages.append(dmg)
                        crit_damage_types.append(damage_types[i])
                roll_properties["critical-damages"] = crit_damages.as_array()
                roll_properties["critical-damage-types"] = crit_damage_types.as_array()
            if save:
                roll_properties["save-ability"] = save[0]
                roll_properties["save-dc"] = save[1]

        if attackInfo or hitInfo:
            return roll_properties
        else:
            return None

    def lookForActions(self, stat_block, add_dice, inject_descriptions):
        blocks = stat_block.find(self._base + "__description-blocks " + self._base + "__description-block")
        makeCB = def(props):
            return def():
                sendRoll(self, "attack", "1d20" + props["to-hit"], props)
        for block in blocks:
            actions = $(block).find(self._base + "__description-block-content p")
            for action in actions:
                #console.log("Found action: ", action)
                firstChild = action.firstElementChild
                if firstChild:
                    # Usually <em><strong> or <strong><em> (Orcus is <span><em><strong>)
                    action_name = $(firstChild).find("> :first-child").text().trim()
                else:
                    if inject_descriptions:
                        injectDiceToRolls(action, self, self._name)
                    continue
                #console.log("Action name: ", action_name)
                if action_name[-1] == ".":
                    action_name = action_name[:-1]
                if add_dice:
                    description = descriptionToString(action)
                    roll_properties = self.buildAttackRoll(action_name, description)
                    if roll_properties:
                        id = addRollButton(self, makeCB(roll_properties), action,
                                           small=True, prepend=True, image=True, text=action_name)
                        $("#" + id).css({"float": "", "text-align": ""})
                if inject_descriptions:
                    injectDiceToRolls(action, self, action_name)

        handleAction = def(action_name, block, action):
            description = $(action).text()
            if action_name[-1] == ".":
                action_name = action_name[:-1]
            if add_dice:
                roll_properties = self.buildAttackRoll(action_name, description)
                if roll_properties:
                    id = addRollButton(self, makeCB(roll_properties), block,
                                        small=True, before=True, image=True, text=action_name)
                    $("#" + id).css({"float": "", "text-align": "", "margin-top": "15px"})
            if inject_descriptions:
                injectDiceToRolls(action, self, action_name)

        # Parse Vehicle (boats) weapons
        blocks = stat_block.find(self._base + "__component-block")
        for block in blocks:
            action_name = $(block).find(self._base + "__component-block-heading").text()
            attributes = $(block).find(self._base + "__component-block-content " + self._base + "__attribute-value")
            for action in attributes:
                description = $(action).text()
                # HACK: Skip ship movement to  avoid having a "-5 ft speed per 25 damage taken" inject dice rolls on '-5'
                if re.search("-\d+ ft. speed", description) is not None:
                    continue
                handleAction(action_name, block, action)

        # Parse Vehicle (boats) weapons (in character extra)
        blocks = stat_block.find(self._base + "-component")
        for block in blocks:
            action_name = $(block).find(self._base + "__section-header").text()
            actions = $(block).find(self._base + "-component__actions")
            # We can't parse each action separately because the entire block is interactive.
            handleAction(action_name, block, actions)

        # Parse Vehicle (infernal machines) features
        blocks = stat_block.find(self._base + "__feature," + self._base + "__features-feature")
        for block in blocks:
            action_name = $(block).find(self._base + "__feature-label").text()
            action = $(block).find(self._base + "__feature-value")
            if action_name == "" and action.length == 0:
                action_name = $(block).find(self._base + "__features-feature-name").text()
                action = $(block).find(self._base + "__features-feature-description")
            handleAction(action_name, block, action)

        # Parse Vehicle (infernal machines) action stations
        blocks = stat_block.find(self._base + "__action-station-block," + self._base + "-action-station")
        for block in blocks:
            action_name = $(block).find(self._base + "__action-station-block-heading").text()
            action = $(block).find(self._base + "__action-station-block-content " + self._base + "__attribute-value")
            if action_name == "" and action.length == 0:
                action_name = $(block).find(self._base + "-action-station__heading").text()
                action = $(block).find(self._base + "-action-station__action")
            handleAction(action_name, block, action)


    def injectSpellRolls(self, element, url):
        icon16 = chrome.extension.getURL("images/icons/icon16.png")

        roll_icon = $('<img class="ct-beyond20-spell-icon" x-beyond20-spell-url="' + url + '"></img>')

        $(element).after(roll_icon)

        $(".ct-beyond20-spell-icon").css("margin-right", "3px")
        $(".ct-beyond20-spell-icon").css("margin-left", "3px")
        $(".ct-beyond20-spell-icon").attr("src", icon16)
        $(".ct-beyond20-spell-icon").off('click')
        $(".ct-beyond20-spell-icon").on('click', def(event):
            spell_url = $(event.currentTarget).attr("x-beyond20-spell-url")
            if spell_url in self._spells:
                self._spells[spell_url].display()
            else:
                #console.log("Fetching Spell Tooltip from URL : ", spell_url)
                $.get(spell_url, def(text):
                    spell_json = JSON.parse(text[1:-1])
                    spell = Spell($(spell_json.Tooltip), self, "tooltip")
                    spell.display()
                    self._spells[spell_url] = spell
                )
        )

    def lookForSpells(self, stat_block):
        spells = stat_block.find(self._base + "__description-blocks a.spell-tooltip")
        for spell in spells:
            tooltip_href = $(spell).attr("data-tooltip-href")
            tooltip_url = re.sub("-tooltip.*$", "/tooltip", tooltip_href)
            self.injectSpellRolls(spell, tooltip_url)

    def updateInfo(self):
        # Creature name could change/be customized in between calls
        self._name = self._stat_block.find(self._base + "__name").text().trim()
        hp = max_hp = temp_hp = None
        groups = $(".ct-creature-pane .ct-collapsible__content .ct-creature-pane__adjuster-group")
        for item in groups:
            label = $(item).find(".ct-creature-pane__adjuster-group-label").text()
            if label == "Current HP":
                hp = int($(item).find(".ct-creature-pane__adjuster-group-value").text())
            elif label == "Max HP":
                max_hp = int($(item).find(".ct-creature-pane__adjuster-group-value").text())
            elif label == "Temp HP":
                temp_hp = int($(item).find(".ct-creature-pane__adjuster-group-value input").val())
        if hp is not None and max_hp is not None and (self._hp != hp or self._max_hp != max_hp or self._temp_hp != temp_hp):
            self._hp = hp
            self._max_hp = max_hp
            self._temp_hp = temp_hp
            print("Monster HP updated to : (" + hp + "+" + temp_hp + ")/" + max_hp)

            req = {"action": "hp-update", "character": self.getDict()}
            console.log("Sending message: ", req)
            chrome.runtime.sendMessage(req, def(resp): beyond20SendMessageFailure(self, resp);)

    def getDict(self):
        return {"name": self._name,
                "avatar": self._avatar,
                "type": self.type(),
                "id": self._id,
                "ac": self._ac,
                "hp": self._hp,
                "hp-formula": self._hp_formula,
                "max-hp": self._max_hp,
                "temp-hp": self._temp_hp,
                "speed": self._speed,
                "abilities": self._abilities.as_array(),
                "saves": self._saves,
                "skills": self._skills,
                "cr": self._cr}


def skillToAbility(skill):
    if skill_abilities[skill]?:
        return skill_abilities[skill]
    return ""

def abbreviationToAbility(abbr):
    for ability in ability_abbreviations:
        if ability_abbreviations[ability] == abbr:
            return ability
    return abbr


def propertyListToDict(propList):
    properties = {}
    for i in range(propList.length):
        label = propList.eq(i).find(".ct-property-list__property-label").text()[:-1]
        value = propList.eq(i).find(".ct-property-list__property-content").text()
        properties[label] = value
    return properties

def descriptionToString(selector):
    # strip tags : https://www.sitepoint.com/jquery-strip-html-tags-div/
    return ($(selector).html() or "").replace(/<\/?[^>]+>/gi, '')

def findToHit(name_to_match, items_selector, name_selector, tohit_selector):
    items = $(items_selector)
    for i in range(items.length):
        if items.eq(i).find(name_selector).text() == name_to_match:
            to_hit = items.eq(i).find(tohit_selector)
            if to_hit.length > 0:
                to_hit = to_hit.text()
                return to_hit
            break
    return None

def damagesToCrits(character, damages):
    crits = []
    rule = int(character.getGlobalSetting("critical-homebrew", CriticalRules.PHB))
    if rule == CriticalRules.HOMEBREW_REROLL or rule == CriticalRules.HOMEBREW_MOD:
        return damages[:]
    for damage in damages:
        damage_parts = re.findall("([0-9]*)d([0-9]+)(ro<2)?", damage).map(def (formula):
            match = re.search("([0-9]*)d([0-9]+)(ro<2)?", formula)
            if rule == CriticalRules.HOMEBREW_MAX:
                dice = int(match.group(1) or 1)
                faces = int(match.group(2))
                return str(dice * faces)
            else:
                return match.group(0)
        )
        console.log("Damage to crits : ", damage, damage_parts)
        crits.append(damage_parts.join(" + "))
    return crits

def buildAttackRoll(character, attack_source, name, description, properties, damages=[], damage_types=[], to_hit=None, brutal=0):
    roll_properties = {"name": name,
                       "attack-source": attack_source,
                       "description": description}
    if to_hit:
        roll_properties["to-hit"] = to_hit

    if properties["Reach"]?:
        roll_properties["reach"] = properties["Reach"]
        roll_properties["attack-type"] = "Melee"
    elif properties["Range"]?:
        roll_properties["range"] = properties["Range"]
        roll_properties["attack-type"] = "Ranged"
    else:
        range_area = properties["Range/Area"] ? ""
        if "Reach" in range_area:
            roll_properties["attack-type"] = "Melee"
            roll_properties["reach"] = range_area.replace(" Reach", "")
        else:
            roll_properties["attack-type"] = "Ranged"
            roll_properties["range"] = range_area
    if properties["Attack Type"]?:
        roll_properties["attack-type"] = properties["Attack Type"]

    if properties["Attack/Save"]?:
        save_ability, save_dc = properties["Attack/Save"].split(" ")
        roll_properties["save-ability"] = abbreviationToAbility(save_ability)
        roll_properties["save-dc"] = save_dc

    if properties["Properties"]?:
        roll_properties["properties"] = properties["Properties"].split(", ")

    if len(damages) > 0:
        roll_properties["damages"] = damages.as_array()
        roll_properties["damage-types"] = damage_types.as_array()
        if to_hit:
            crits = damagesToCrits(character, damages, damage_types)
            crit_damages = []
            crit_damage_types = []
            for i, dmg in enumerate(crits):
                if dmg != "":
                    crit_damages.append(dmg)
                    crit_damage_types.append(damage_types[i])
            if brutal > 0:
                highest_dice = 0
                for dmg in crit_damages:
                    match = re.search("[0-9]*d([0-9]+)", dmg)
                    if match?:
                        sides = int(match.group(1))
                        if sides > highest_dice:
                            highest_dice = sides
                if highest_dice != 0:
                    crit_damages.append(str(brutal) + "d" + str(highest_dice))
                    crit_damage_types.append("Brutal")
            roll_properties["critical-damages"] = crit_damages.as_array()
            roll_properties["critical-damage-types"] = crit_damage_types.as_array()

    return roll_properties

def sendRoll(character, rollType, fallback, args):
    nonlocal key_modifiers

    whisper = int(character.getGlobalSetting("whisper-type", WhisperType.NO))
    whisper_monster = int(character.getGlobalSetting("whisper-type-monsters", WhisperType.YES))
    if (character.type() == "Monster" or character.type() == "Vehicle") and whisper_monster != WhisperType.NO:
        whisper = whisper_monster
    advantage = int(character.getGlobalSetting("roll-type", RollType.NORMAL))
    if args["advantage"] == RollType.OVERRIDE_ADVANTAGE:
        args["advantage"] =  RollType.SUPER_ADVANTAGE if advantage == RollType.SUPER_ADVANTAGE else RollType.ADVANTAGE

    # Default advantage/whisper would get overriden if they are part of provided args
    req = {"action": "roll", "character": character.getDict(), "type": rollType, "roll": fallback,
           "advantage": advantage, "whisper": whisper}
    if character.getGlobalSetting("weapon-force-critical", False):
        req["critical-limit"] = 1
    for key in args:
        req[key] = args[key]
    if key_modifiers.shift:
        req["advantage"] = RollType.ADVANTAGE
    elif key_modifiers.ctrl:
        req["advantage"] = RollType.DISADVANTAGE
    elif key_modifiers.alt:
        req["advantage"] = RollType.NORMAL

    console.log("Sending message: ", req)
    chrome.runtime.sendMessage(req, def(resp): beyond20SendMessageFailure(character, resp);)

def isRollButtonAdded():
    return $(".ct-beyond20-roll,.ct-beyond20-roll-display").length > 0

def isCustomRollIconsAdded():
    return $(".ct-beyond20-custom-roll").length > 0

def isHitDieButtonAdded():
    return $(".ct-beyond20-roll-hitdie").length > 0

def getRollTypeButtonClass(character):
    if character?:
        advantage = int(character.getGlobalSetting("roll-type", RollType.NORMAL))
    if key_modifiers.shift:
        advantage = RollType.ADVANTAGE
    elif key_modifiers.ctrl:
        advantage = RollType.DISADVANTAGE
    elif key_modifiers.alt:
        advantage = RollType.NORMAL
    if advantage == RollType.DOUBLE:
        return "beyond20-roll-type-double"
    if advantage == RollType.QUERY:
        return "beyond20-roll-type-query"
    if advantage == RollType.THRICE:
        return "beyond20-roll-type-thrice"
    if advantage == RollType.ADVANTAGE:
        return "beyond20-roll-type-advantage"
    if advantage == RollType.DISADVANTAGE:
        return "beyond20-roll-type-disadvantage"
    if advantage == RollType.SUPER_ADVANTAGE:
        return "beyond20-roll-type-super-advantage"
    if advantage == RollType.SUPER_DISADVANTAGE:
        return "beyond20-roll-type-super-disadvantage"
    return ""

last_character_used = None
def updateRollTypeButtonClasses(character):
    nonlocal last_character_used
    button_roll_type_classes="beyond20-roll-type-double beyond20-roll-type-query beyond20-roll-type-thrice beyond20-roll-type-advantage beyond20-roll-type-disadvantage beyond20-roll-type-super-advantage beyond20-roll-type-super-disadvantage"
    rolltype_class = getRollTypeButtonClass(character or last_character_used)
    $(".ct-beyond20-roll .ct-beyond20-roll-button,.beyond20-quick-roll-tooltip").removeClass(button_roll_type_classes).addClass(rolltype_class)


button_class = "ct-theme-button ct-theme-button--filled ct-theme-button--interactive ct-button character-button"
button_class_small = button_class + " character-button-small"
def addRollButton(character, callback, where, small=False, append=False, prepend=False, before=False, image=True, text="Beyond 20"):
    nonlocal last_character_used
    last_character_used = character

    icon32 = chrome.extension.getURL("images/dice24.png")
    icon16 = chrome.extension.getURL("images/dice16.png")
    id = uuid.uuid4()

    rolltype_class = " " + getRollTypeButtonClass(character)

    button = E.div(class_="ct-beyond20-roll", id=str(id),
                    E.button(class_="ct-beyond20-roll-button " + (button_class_small if small else button_class) + rolltype_class,
                             E.img(class_="ct-beyond20-icon", src=((icon16 if small else icon32) if image else ""),
                                   style=("margin-right: 6px;" if image else "")),
                             E.span(class_="ct-button__content", text)
                             )
                    )

    if append:
        $(where).append(button)
    elif prepend:
        $(where).prepend(button)
    elif before:
        $(where).before(button)
    else:
        $(where).after(button)
    $("#" + str(id)).css({"float": "right",
                                "display": "block",
                                "text-align": "center"})
    $("#" + str(id) + " button").on('click', def(event):
        callback()
    )
    return id

def addDisplayButton(callback, where, text="Display in VTT", append=True, small=True):
    button = E.div(class_="ct-beyond20-roll-display",
                   E.button(class_="ct-beyond20-display-button " + (button_class_small if small else button_class).replace("filled", "outline"),
                            E.span(class_="ct-button__content", text)
                            )
                   )
    if append:
        $(where).append(button)
    else:
        $(where).after(button)
    $(".ct-beyond20-roll-button").css({"margin-left": "auto",
                                       "margin-right": "auto"})
    $(".ct-beyond20-roll-display").css("margin-top", "2px")
    $(".ct-beyond20-roll-display").on('click', def(event):
        callback()
    )

def addHitDieButtons(rollCallback):
    icon16 = chrome.extension.getURL("images/icons/icon16.png")
    button = E.div(class_="ct-beyond20-roll-hitdie", style="float: right;",
                    E.img(class_="ct-beyond20-icon", src=icon16, style="margin-right: 6px;"),
                    E.button(class_="ct-beyond20-roll-button " + button_class_small,
                             E.span(class_="ct-button__content", "Roll Hit Die")
                             )
                    )
    print("Adding Hit Dice buttons")

    $(".ct-reset-pane__hitdie-heading").append(button)
    hitdice = $(".ct-reset-pane__hitdie")
    multiclass = hitdice.length > 1
    for i in range(hitdice.length):
        cb = def(rollCallback, index):
            return def(event):
                rollCallback(multiclass, index)

        $(".ct-beyond20-roll-hitdie").eq(i).on('click', cb(rollCallback, i))

def addIconButton(callback, where, append=False, prepend=False):
    icon16 = chrome.extension.getURL("images/icons/icon16.png")
    id = uuid.uuid4()
    button = E.span(class_="ct-beyond20-roll", id=str(id),
                    style="margin-right:3px; margin-left: 3px;",
                    E.img(class_="ct-beyond20-icon", src=icon16))

    if append:
        $(where).append(button)
    elif prepend:
        $(where).prepend(button)
    else:
        $(where).after(button)
    $("#" + str(id)).on('click', def(event):
        callback()
    )

def removeRollButtons():
    $(".ct-beyond20-roll").remove()
    $(".ct-beyond20-roll-hitdie").remove()
    $(".ct-beyond20-roll-display").remove()
    $(".ct-beyond20-custom-icon").remove()
    custom_rolls = $("u.ct-beyond20-custom-roll")
    for i in range(custom_rolls.length):
        custom_rolls.eq(i).replaceWith(custom_rolls.eq(i).text())


def recursiveDiceReplace(node, cb):
    if node.hasChildNodes():
        # We need to copy the list since its size could change as we modify it
        children = list(node.childNodes)
        for child in children:
            # don't replace anything inside of a roll button itself
            if $(child).hasClass("ct-beyond20-roll"):
                continue
            recursiveDiceReplace(child, cb)
    elif node.nodeName == "#text":
        text = replaceRolls(node.textContent, cb)
        # Only replace if we changed it, otherwise we might break existing html code bindings
        if text != node.textContent:
            $(node).replaceWith($.parseHTML(text))

def injectDiceToRolls(selector, character, name=""):
    icon16 = chrome.extension.getURL("images/icons/icon16.png")
    replaceCB = def(dice, modifier):
        dice_formula = ("1d20" if dice == "" else dice) + modifier
        return '<u class="ct-beyond20-custom-roll"><strong>' + dice + modifier + '</strong>' + \
            '<img class="ct-beyond20-custom-icon" x-beyond20-name="' + name + \
            '" x-beyond20-roll="' + dice_formula + '"></img></u>'

    items = $(selector)
    for item in items:
        recursiveDiceReplace(item, replaceCB)

    $(".ct-beyond20-custom-icon").css("margin-right", "3px")
    $(".ct-beyond20-custom-icon").css("margin-left", "3px")
    $(".ct-beyond20-custom-icon").attr("src", icon16)
    $(".ct-beyond20-custom-roll").off('click')
    $(".ct-beyond20-custom-roll").on('click', def(event):
        name = $(event.currentTarget).find("img").attr("x-beyond20-name")
        roll = $(event.currentTarget).find("img").attr("x-beyond20-roll")
        sendRoll(character, "custom", roll, {"name": name})
    )

def beyond20SendMessageFailure(character, response):
    if not response ?:
        return
    console.log("Received response : ", response)
    if response.request.action == "roll" and (response.vtt == "dndbeyond" or response.error?):
        dndbeyondDiceRoller.handleRollError(response.request, response.error)
    elif response.error?:
        alertify.error("<strong>Beyond 20 : </strong>" + response.error)

alertify.set("alert", "title", "Beyond 20")
alertify.set("notifier", "position", "top-center")

key_modifiers = {"alt": False, "ctrl": False, "shift": False}
checkKeyModifiers = def(event):
    nonlocal key_modifiers
    if event.originalEvent.repeat:
        return
    needsUpdate = Object.values(key_modifiers).some(def (v): return v;)
    key_modifiers.ctrl = event.ctrlKey or event.metaKey
    key_modifiers.shift = event.shiftKey
    key_modifiers.alt = event.altKey
    needsUpdate = needsUpdate or Object.values(key_modifiers).some(def (v): return v;)
    if needsUpdate:
        updateRollTypeButtonClasses()
resetKeyModifiers = def(event):
    nonlocal key_modifiers
    needsUpdate = Object.values(key_modifiers).some(def (v): return v;)
    key_modifiers.ctrl = False
    key_modifiers.shift = False
    key_modifiers.alt = False
    if needsUpdate:
        updateRollTypeButtonClasses()
$(window).keydown(checkKeyModifiers).keyup(checkKeyModifiers).blur(resetKeyModifiers)
