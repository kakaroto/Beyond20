from settings import getDefaultSettings, getStoredSettings, RollType
from utils import isExtensionDisconnected, alertQuickSettings, alertFullSettings, injectCSS
from elementmaker import E
import math
import re
from dndbeyond import Character, Monster, buildAttackRoll, sendRoll, \
    ability_abbreviations, findToHit, descriptionToString, propertyListToDict, \
    injectDiceToRolls, addIconButton, addHitDieButtons, addDisplayButton, addRollButton, \
    isHitDieButtonAdded, isRollButtonAdded, isCustomRollIconsAdded, removeRollButtons, getRollTypeButtonClass
from constants import ROLLTYPE_STYLE_CSS

console.log("Beyond20: D&D Beyond module loaded.")

def sendRollWithCharacter(rollType, fallback, args):
    nonlocal character
    nonlocal settings

    sendRoll(character, rollType, fallback, args)


def rollSkillCheck(paneClass):
    nonlocal character, settings

    skill_name = $("." + paneClass + "__header-name").text()
    ability = $("." + paneClass + "__header-ability").text()
    modifier = $("." + paneClass + "__header-modifier").text()
    proficiency = $("." + paneClass + "__header-icon .ct-tooltip").attr("data-original-title")
    #console.log("Skill " + skill_name + "(" + ability + ") : " + modifier)
    roll_properties = {"skill": skill_name,
                       "ability": ability,
                       "modifier": modifier,
                       "proficiency": proficiency}
    if ability == "STR" and \
        ((character.hasClassFeature("Rage") and character.getSetting("barbarian-rage", False)) or \
         (character.hasClassFeature("Giant Might") and character.getSetting("fighter-giant-might", False))):
        roll_properties["advantage"] = RollType.ADVANTAGE
    sendRollWithCharacter("skill", "1d20" + modifier, roll_properties)

def rollAbilityOrSavingThrow(paneClass, rollType):
    nonlocal character

    ability_string = $("." + paneClass + " .ct-sidebar__heading").text()
    ability_name = ability_string.split(" ")[0]
    modifier = $("." + paneClass + "__modifier .ct-signed-number").text()
    ability = ability_abbreviations[ability_name]

    if rollType == "ability" and character.hasClassFeature("Jack of All Trades") and \
            character.getSetting("bard-joat", False):
        JoaT = int(math.floor(float(character._proficiency) / 2))
        modifier += " + " + JoaT

    roll_properties = {"name" : ability_name,
                       "ability": ability,
                       "modifier": modifier}

    if ability == "STR" and \
        ((character.hasClassFeature("Rage") and character.getSetting("barbarian-rage", False)) or \
         (character.hasClassFeature("Giant Might") and character.getSetting("fighter-giant-might", False))):
        roll_properties["advantage"] = RollType.ADVANTAGE
    sendRollWithCharacter(rollType, "1d20" + modifier, roll_properties)

def rollAbilityCheck():
    rollAbilityOrSavingThrow("ct-ability-pane", "ability")

def rollSavingThrow():
    rollAbilityOrSavingThrow("ct-ability-saving-throws-pane", "saving-throw")

def rollInitiative():
    initiative = $(".ct-initiative-box__value").text()
    advantage = $(".ct-initiative-box__advantage").length > 0
    if initiative == "":
        initiative = $(".ct-combat-mobile__extra--initiative .ct-combat-mobile__extra-value").text()
        advantage = $(".ct-combat-mobile__advantage").length > 0
    #console.log("Initiative " + ("with" if advantage else "without") + " advantage : " + initiative)
    roll_properties = {"initiative": initiative}
    if advantage:
        roll_properties["advantage"] = RollType.ADVANTAGE
    sendRollWithCharacter("initiative", "1d20" + initiative, roll_properties)

        
def rollHitDie(multiclass, index):
    #console.log("Rolling hit die index " + index)
    hitdie = $(".ct-reset-pane__hitdie").eq(index)
    class_name = hitdie.find(".ct-reset-pane__hitdie-heading-class").text()
    text = hitdie.find(".ct-reset-pane__hitdie-heading").text()
    die = text.split("Hit Die: ")[1].split(" ")[0]
    sendRollWithCharacter("hit-dice", die, {"class": class_name,
                               "multiclass": multiclass,
                               "hit-dice": die} )

def rollItem(force_display=False):
    nonlocal character

    prop_list = $(".ct-item-pane .ct-property-list .ct-property-list__property")
    properties = propertyListToDict(prop_list)
    #console.log("Properties are : " + str(properties))
    item_name = $(".ct-item-pane .ct-item-name")[0].firstChild.textContent
    item_type = $(".ct-item-detail__intro").text()
    description = descriptionToString(".ct-item-detail__description")
    if force_display is False and "Damage" in properties:
        item_full_name = $(".ct-item-pane .ct-item-name").text()
        to_hit = properties["To Hit"] ? \
            findToHit(item_full_name, ".ct-combat-attack--item", ".ct-item-name", ".ct-combat-attack__tohit")

        if to_hit ?:
            character._cacheToHit(item_full_name, to_hit)
        else:
            to_hit = character._getToHitCache(item_full_name)

        damages = []
        damage_types = []
        for i in range(prop_list.length):
            if prop_list.eq(i).find(".ct-property-list__property-label").text() == "Damage:":
                value = prop_list.eq(i).find(".ct-property-list__property-content")
                damage = value.find(".ct-damage__value").text()
                damage_type = properties["Damage Type"] ? ""
                versatile_damage = value.find(".ct-item-detail__versatile-damage").text()[1:-1]
                if damages.length == 0 and character.hasClassFeature("Fighting Style: Great Weapon Fighting") and \
                    properties["Attack Type"] == "Melee" and \
                    (properties["Properties"].includes("Versatile") or properties["Properties"].includes("Two-Handed")) :
                        if versatile_damage != "":
                            versatile_damage = re.sub("[0-9]*d[0-9]+", "\\0ro<2", versatile_damage)
                        else:
                            damage = re.sub("[0-9]*d[0-9]+", "\\0ro<2", damage)

                if versatile_damage != "":
                    versatile_choice = character.getSetting("versatile-choice", "both")
                    if versatile_choice == "one":
                        damages.append(damage)
                        damage_types.append(damage_type)
                    elif versatile_choice == "two":
                        damages.append(versatile_damage)
                        damage_types.append(damage_type)
                    else:
                        damages.append(damage)
                        damage_types.append(damage_type)
                        damages.append(versatile_damage)
                        damage_types.append("Two-Handed")
                else:
                    damages.append(damage)
                    damage_types.append(damage_type)
                additional_damages = value.find(".ct-item-detail__additional-damage")
                for j in range(additional_damages.length):
                    dmg = additional_damages.eq(j).text()
                    dmg_type = additional_damages.eq(j).find(".ct-damage-type-icon .ct-tooltip").attr("data-original-title")
                    dmg_info = additional_damages.eq(j).find(".ct-item-detail__additional-damage-info").text()
                    if dmg != "":
                        dmg = dmg.replace(dmg_info, "")
                        if dmg_info != "":
                            dmg_type += "(" + dmg_info + ")"
                        damages.append(dmg)
                        damage_types.append(dmg_type)
                break

        custom_damages = character.getSetting("custom-damage-dice", "")
        if len(custom_damages) > 0:
            for custom_damage in custom_damages.split(","):
                damages.append(custom_damage.trim())
                damage_types.append("Custom")
        if "Rogue" in character._classes and \
                character.getSetting("rogue-sneak-attack", False) and \
                (properties["Attack Type"] == "Ranged" or \
                     (properties["Properties"]? and properties["Properties"].includes("Finesse"))):
            sneak_attack = int(math.ceil(float(character._classes["Rogue"]) / 2)) + "d6"
            damages.append(sneak_attack)
            damage_types.append("Sneak Attack")
        if character.getSetting("sharpshooter", False) and \
                properties["Attack Type"] == "Ranged" and \
                properties["Proficient"] == "Yes":
            to_hit += " - 5"
            damages.insert(1, " + 10")
            damage_types.insert(1, "Sharpshooter")
            character.mergeCharacterSettings({"sharpshooter": False})
        if character.getSetting("great-weapon-master", False) and \
                properties["Attack Type"] == "Melee" and \
                properties["Properties"].includes("Heavy") and \
                properties["Proficient"] == "Yes":
            to_hit += " - 5"
            damages.insert(1, " + 10")
            damage_types.insert(1, "Weapon Master")
            character.mergeCharacterSettings({"great-weapon-master": False})
        if character.getSetting("bloodhunter-crimson-rite", False) and \
            character.hasClassFeature("Crimson Rite"):
            bloodhunter_level = character.getClassLevel("Blood Hunter")
            if bloodhunter_level > 0:
                if bloodhunter_level <= 4:
                    rite_die = "1d4"
                elif bloodhunter_level <= 10:
                    rite_die = "1d6"
                elif bloodhunter_level <= 16:
                    rite_die = "1d8"
                else:
                    rite_die = "1d10"
                damages.append(rite_die)
                damage_types.append("Crimson Rite")
        if character.getSetting("ranger-dread-ambusher", False):
            damages.append("1d8")
            damage_types.append("Ambush")
            character.mergeCharacterSettings({"ranger-dread-ambusher": False})
        if properties["Attack Type"] == "Melee" and \
           character.hasClassFeature("Improved Divine Smite") and \
           character.getSetting("paladin-improved-divine-smite", True):
            damages.append("1d8")
            damage_types.append("Radiant")
        if damages.length > 0 and \
           character.getSetting("warlock-hexblade-curse", False) and \
           character.hasClassFeature("Hexblade’s Curse") and \
           character._proficiency is not None:
            damages.append(character._proficiency)
            damage_types.append("Hexblade's Curse")
        # Fighter's Giant Might
        if character.hasClassFeature("Giant Might") and character.getSetting("fighter-giant-might", False):
            damages.append("1d6")
            damage_types.append("Giant Might")
        # Cleric's Divine Strike
        if properties["Attack Type"] == "Melee" and \
            character.hasClassFeature("Divine Strike") and \
            character.getSetting("cleric-divine-strike", True):
            cleric_level = character.getClassLevel("Cleric")
            damages.append("1d8" if cleric_level < 14 else "2d8")
            damage_types.append("Divine Strike")
        # Bard's Psychic blades
        if character.hasClassFeature("Psychic Blades") and \
            character.getSetting("bard-psychic-blades", False):
            bard_level = character.getClassLevel("Bard")
            damages.append("2d6" if bard_level < 5 else ("3d6" if bard_level < 10 else ("5d6" if bard_level < 15 else "8d6")))
            damage_types.append("Psychic")
            character.mergeCharacterSettings({"bard-psychic-blades": False})

        critical_limit = 20
        if character.hasAction("Channel Divinity: Legendary Strike") and \
           character.getSetting("paladin-legendary-strike", False):
            critical_limit = 19
        if character.hasClassFeature("Hexblade’s Curse") and \
           character.getSetting("warlock-hexblade-curse", False):
            critical_limit = 19
        if character.hasClassFeature("Improved Critical"):
            critical_limit = 19
        if character.hasClassFeature("Superior Critical"):
            critical_limit = 18

        brutal = 0
        if properties["Attack Type"] == "Melee":
            if character.getSetting("brutal-critical"):
                if character.hasClassFeature("Brutal Critical"):
                    barbarian_level = character.getClassLevel("Barbarian")
                    brutal += 1 + math.floor((barbarian_level - 9) / 4)
                if character.hasRacialTrait("Savage Attacks"):
                    brutal += 1
            if character.hasClassFeature("Rage") and character.getSetting("barbarian-rage", False):
                barbarian_level = character.getClassLevel("Barbarian")
                rage_damage = 2 if barbarian_level < 9 else (3 if barbarian_level < 16 else 4)
                damages.insert(1, str(rage_damage))
                damage_types.insert(1, "Rage")
        roll_properties = buildAttackRoll(character,
                                          "item",
                                          item_name,
                                          description,
                                          properties,
                                          damages,
                                          damage_types,
                                          to_hit,
                                          brutal)
        roll_properties["item-type"] = item_type
        if critical_limit != 20:
            roll_properties["critical-limit"] = critical_limit
            
        # Asssassinate: consider all rolls as critical
        if character.hasClassFeature("Assassinate") and \
           character.getSetting("rogue-assassinate", False):
            roll_properties["critical-limit"] = 1
            roll_properties["advantage"] = RollType.ADVANTAGE
            character.mergeCharacterSettings({"rogue-assassinate": False})
        sendRollWithCharacter("attack", damages[0], roll_properties)
    else:
        sendRollWithCharacter("item", 0, {"name": item_name,
                             "description" : description,
                             "item-type": item_type})        

def rollAction(paneClass):
    nonlocal character
    properties = propertyListToDict($("." + paneClass + " .ct-property-list .ct-property-list__property"))
    #console.log("Properties are : " + str(properties))
    action_name = $(".ct-sidebar__heading").text()
    action_parent = $(".ct-sidebar__header-parent").text()
    description = descriptionToString(".ct-action-detail__description")

    if action_name == "Superiority Dice" or action_parent == "Maneuvers":
        fighter_level = character.getClassLevel("Fighter")
        superiority_die = "1d8" if fighter_level < 10 else ("1d10" if fighter_level < 18 else "1d12")
        sendRollWithCharacter("custom", superiority_die, {"name": action_name,
                                                          "description": description,
                                                          "modifier": superiority_die})
                                                          
    elif action_name == "Bardic Inspiration" or action_parent == "Blade Flourish":
        bard_level = character.getClassLevel("Bard")
        inspiration_die = "1d6" if bard_level < 5 else ("1d8" if bard_level < 10 else ("1d10" if bard_level < 15 else "1d12"))
        sendRollWithCharacter("custom", inspiration_die, {"name": action_name,
                                                          "description": description,
                                                          "modifier": inspiration_die})
    elif "Damage" in properties or properties["To Hit"]? or properties["Attack/Save"]?:
        if "Damage" in properties:
            damages = [properties["Damage"]]
            damage_types = [properties["Damage Type"] ? ""]
            if character.getSetting("warlock-hexblade-curse", False) and \
                character.hasClassFeature("Hexblade’s Curse") and \
                character._proficiency is not None:
                damages.append(character._proficiency)
                damage_types.append("Hexblade's Curse")
        else:
            damages = []
            damage_types = []

        custom_damages = character.getSetting("custom-damage-dice", "")
        if len(custom_damages) > 0:
            for custom_damage in custom_damages.split(","):
                damages.append(custom_damage.trim())
                damage_types.append("Custom")

        brutal = 0
        critical_limit = 20
        # Polearm master bonus attack using the other end of the polearm is considered a melee attack. 
        if action_name == "Polearm Master - Bonus Attack":
            if character.hasAction("Channel Divinity: Legendary Strike") and \
                character.getSetting("paladin-legendary-strike", False):
                critical_limit = 19
            if character.hasClassFeature("Hexblade’s Curse") and \
                character.getSetting("warlock-hexblade-curse", False):
                critical_limit = 19
            if character.hasClassFeature("Improved Critical"):
                critical_limit = 19
            if character.hasClassFeature("Superior Critical"):
                critical_limit = 18

            if character.getSetting("brutal-critical"):
                if character.hasClassFeature("Brutal Critical"):
                    barbarian_level = character.getClassLevel("Barbarian")
                    brutal += 1 + math.floor((barbarian_level - 9) / 4)
                if character.hasRacialTrait("Savage Attacks"):
                    brutal += 1
            if character.hasClassFeature("Rage") and character.getSetting("barbarian-rage", False):
                barbarian_level = character.getClassLevel("Barbarian")
                rage_damage = 2 if barbarian_level < 9 else (3 if barbarian_level < 16 else 4)
                damages.insert(1, str(rage_damage))
                damage_types.insert(1, "Rage")
            if character.hasClassFeature("Giant Might") and character.getSetting("fighter-giant-might", False):
                damages.append("1d6")
                damage_types.append("Giant Might")

        roll_properties = buildAttackRoll(character,
                                          "action",
                                          action_name,
                                          description,
                                          properties,
                                          damages,
                                          damage_types,
                                          properties["To Hit"] ? None,
                                          brutal)

        if critical_limit != 20:
            roll_properties["critical-limit"] = critical_limit

        # Asssassinate: consider all rolls as critical
        if character.hasClassFeature("Assassinate") and \
           character.getSetting("rogue-assassinate", False):
            roll_properties["critical-limit"] = 1
            roll_properties["advantage"] = RollType.ADVANTAGE
            character.mergeCharacterSettings({"rogue-assassinate": False})
        sendRollWithCharacter("attack", damages[0], roll_properties)
    else:
        sendRollWithCharacter("action", 0, {"name": action_name,
                                            "description" : description})
        
def rollSpell(force_display=False):
    nonlocal character
    properties = propertyListToDict($(".ct-spell-pane .ct-property-list .ct-property-list__property"))
    #console.log("Properties are : " + str(properties))
    spell_source = $(".ct-sidebar__header-parent").text()
    spell_full_name = $(".ct-sidebar__heading .ct-spell-name").text()
    spell_name = $(".ct-sidebar__heading .ct-spell-name")[0].firstChild.textContent
    description = descriptionToString(".ct-spell-pane .ct-spell-detail__description")
    damage_modifiers = $(".ct-spell-pane .ct-spell-caster__modifiers--damages .ct-spell-caster__modifier--damage")
    healing_modifiers = $(".ct-spell-pane .ct-spell-caster__modifiers--healing .ct-spell-caster__modifier--hp")
    temp_hp_modifiers = $(".ct-spell-pane .ct-spell-caster__modifiers--healing .ct-spell-caster__modifier--temp")
    castas = $(".ct-spell-caster__casting-level-current").text()
    level = $(".ct-spell-pane .ct-spell-detail__level-school-item").toArray().map(def (i): return i.textContent;).join(" ")
    concentration = $(".ct-spell-pane .ct-spell-name__icon--concentration").length > 0
    ritual = $(".ct-spell-pane .ct-spell-name__icon--ritual").length > 0
    duration = properties["Duration"] ? ""
    if "Concentration" in duration:
        duration = duration.replace("Concentration, ", "")
        concentration = True
    else:
        concentration = False
    to_hit = properties["To Hit"] ? \
        findToHit(spell_full_name, ".ct-combat-attack--spell", ".ct-spell-name", ".ct-combat-attack__tohit")
    if not to_hit:
        to_hit = findToHit(spell_full_name, ".ct-spells-spell", ".ct-spell-name", ".ct-spells-spell__tohit")

    if force_display is False and (damage_modifiers.length > 0 or healing_modifiers.length > 0 or temp_hp_modifiers.length > 0 or to_hit != None):
        damages = []
        damage_types = []
        for modifier in damage_modifiers:
            dmg = $(modifier).find(".ct-spell-caster__modifier-amount").text()
            dmgtype = $(modifier).find(".ct-damage-type-icon .ct-tooltip").attr("data-original-title")
            if not dmgtype?:
                dmgtype = ""
            damages.append(dmg)
            damage_types.append(dmgtype)

        # Handle special spells
        if spell_name == "Absorb Elements":
            damages = [damages[0]]
            damage_types = ["Triggering Type"]

        # Hex blade's curse only applies if there are damages
        if damages.length > 0 and \
            character.getSetting("warlock-hexblade-curse", False) and \
            character.hasClassFeature("Hexblade’s Curse") and \
            character._proficiency is not None:
            damages.append(character._proficiency)
            damage_types.append("Hexblade's Curse")
            
        if damages.length > 0 and \
            character.hasClassFeature("Arcane Firearm") and \
            character.getSetting("artificer-arcane-firearm", False) and \
            spell_source == "Artificer":
            damages.append("1d8")
            damage_types.append("Arcane Firearm")
        
        # Check for Draconic Sorcerer's Elemental Affinity
        elementalAffinity = None
        for feature in character._class_features:
            match = feature.match("Elemental Affinity \\((.*)\\)")
            if match:
                elementalAffinity = match[1]
                break
        if elementalAffinity and elementalAffinity in damage_types:
            for ability in character._abilities:
                if ability[1] == "CHA" and ability[3] != "" and ability[3] != "0":
                    damages.append(ability[3])
                    damage_types.append(elementalAffinity + " (Elemental Affinity)")

        # We can then add healing types
        for modifier in healing_modifiers:
            dmg = $(modifier).find(".ct-spell-caster__modifier-amount").text()
            if dmg.startsWith("Regain "):
                dmg = dmg[7:]
            if dmg.endsWith(" Hit Points"):
                dmg = dmg[:-11]
            if len(dmg) > 0:
                damages.append(dmg)
                damage_types.append("Healing")

        # We can then add temp healing types
        for modifier in temp_hp_modifiers:
            dmg = $(modifier).find(".ct-spell-caster__modifier-amount").text()
            if dmg.startsWith("Regain "):
                dmg = dmg[7:]
            if dmg.endsWith(" Temp Hit Points"):
                dmg = dmg[:-16]
            if len(dmg) > 0:
                damages.append(dmg)
                damage_types.append("Temp HP")

        # Handle Disciple of life
        if healing_modifiers.length > 0 and \
                character.hasClassFeature("Disciple of Life") and \
                character.getSetting("cleric-disciple-life", False):
            spell_level = level[0]
            if castas != "":
                spell_level = castas[0]
            damages.append(str(2 + int(spell_level)))
            damage_types.append("Disciple of Life")

        custom_damages = character.getSetting("custom-damage-dice", "")
        if len(custom_damages) > 0:
            for custom_damage in custom_damages.split(","):
                damages.append(custom_damage.trim())
                damage_types.append("Custom")

        roll_properties = buildAttackRoll(character,
                                          "spell",
                                          spell_name,
                                          description,
                                          properties,
                                          damages,
                                          damage_types,
                                          to_hit)

        spell_properties = {"level-school": level,
                            "concentration": concentration,
                            "duration": duration,
                            "casting-time": (properties["Casting Time"] ? ""),
                            "components": (properties["Components"] ? ""),
                            "ritual": ritual}
        for key in spell_properties:
            roll_properties[key] = spell_properties[key]
        if castas != "" and not level.startsWith(castas):
            roll_properties["cast-at"] = castas
            
        # Asssassinate: consider all rolls as critical
        if character.hasClassFeature("Assassinate") and \
           character.getSetting("rogue-assassinate", False):
            roll_properties["critical-limit"] = 1
            roll_properties["advantage"] = RollType.ADVANTAGE
            character.mergeCharacterSettings({"rogue-assassinate": False})

        sendRollWithCharacter("spell-attack", damages[0] ? "", roll_properties)
    else:
        roll_properties = {"name": spell_name,
                           "level-school": level,
                           "range": (properties["Range/Area"] ? ""),
                           "concentration": concentration,
                           "duration": duration,
                           "casting-time": (properties["Casting Time"] ? ""),
                           "components": (properties["Components"] ? ""),
                           "ritual": ritual,
                           "description" : description}
        if castas != "" and not level.startsWith(castas):
            roll_properties["cast-at"] = castas
        sendRollWithCharacter("spell-card", 0, roll_properties)

def displayItem():
    rollItem(True)

def displaySpell():
    rollSpell(True)

def displayFeature(paneClass):
    source_types = {"ct-class-feature-pane": "Class",
               "ct-racial-trait-pane": "Race",
               "ct-feat-pane": "Feat"}
    name = $(".ct-sidebar__heading").text()
    source = $(".ct-sidebar__header-parent").text()
    source_type = source_types[paneClass]
    description = descriptionToString(".ct-snippet__content")
    sendRollWithCharacter("feature", 0, {"name": name,
                            "source": source,
                            "source-type": source_type,
                            "description": description} )

def displayTrait():
    trait = $(".ct-sidebar__heading").text()
    description = $(".ct-trait-pane__input").text()
    sendRollWithCharacter("trait", 0, {"name": trait,
                            "description": description})
                            
def displayAction(paneClass):
    action_name = $(".ct-sidebar__heading").text()
    description = descriptionToString(".ct-action-detail__description")
    sendRollWithCharacter("action", 0, {"name": action_name,
                                        "description" : description})

def execute(paneClass):
    console.log("Beyond20: Executing panel : " + paneClass)
    if paneClass in ["ct-skill-pane", "ct-custom-skill-pane"]:
        rollSkillCheck(paneClass)
    elif paneClass == "ct-ability-pane":
        rollAbilityCheck()
    elif paneClass == "ct-ability-saving-throws-pane":
        rollSavingThrow()
    elif paneClass == "ct-initiative-pane":
        rollInitiative()
    elif paneClass == "ct-item-pane":
        rollItem()
    elif paneClass in ["ct-action-pane", "ct-custom-action-pane"]:
        rollAction(paneClass)
    elif paneClass == "ct-spell-pane":
        rollSpell()
    else:
        displayPanel(paneClass)

def displayPanel(paneClass):
    console.log("Beyond20: Displaying panel : " + paneClass)
    if paneClass == "ct-item-pane":
        displayItem()
    elif paneClass == "ct-spell-pane":
        displaySpell()
    elif paneClass in ["ct-class-feature-pane", "ct-racial-trait-pane", "ct-feat-pane"]:
        displayFeature(paneClass)
    elif paneClass == "ct-trait-pane":
        displayTrait()
    elif paneClass in ["ct-action-pane", "ct-custom-action-pane"]:
        displayAction(paneClass)
    else:
        alertify.alert("Not recognizing the currently open sidebar")

def findModifiers(character, custom_roll):
    sibling = custom_roll.nextSibling
    if sibling and sibling.nodeName == "#text":
        strong = $(custom_roll).find("strong")
        img = $(custom_roll).find("img")
        roll_formula = img.attr("x-beyond20-roll")
        text = sibling.textContent
        text_len = 0
        while text_len != len(text):
            # If text length changes, we can check again for another modifier
            text_len = len(text)
            for ability in character._abilities:
                mod_string = " + your " + ability[0] + " modifier"
                if text.startsWith(mod_string):
                    strong.append(mod_string)
                    roll_formula += ability[3]
                    text = text.substring(len(mod_string))
            for class_name in character._classes:
                mod_string = " + your " + class_name.toLowerCase() + " level"
                if text.startsWith(mod_string):
                    strong.append(mod_string)
                    roll_formula += " + " + character._classes[class_name]
                    text = text.substring(len(mod_string))
            
            mod_string = " + your proficiency bonus"
            if text.startsWith(mod_string):
                strong.append(mod_string)
                roll_formula += character.proficiency
                text = text.substring(len(mod_string))

        sibling.textContent = text
        img.attr("x-beyond20-roll", roll_formula)
            

def checkAndInjectDiceToRolls(selector, name=""):
    nonlocal settings
    nonlocal character
    if not settings["subst-dndbeyond"]:
        return

    injectDiceToRolls(selector, character, name)

    for custom_roll in $(".ct-beyond20-custom-roll"):
        findModifiers(character, custom_roll)

def addRollButtonEx(paneClass, where, small=False, append=False, prepend=False, image=True, text="Beyond 20"):
    nonlocal character
    callback = def():
        execute(paneClass)
    addRollButton(character, callback, where, small=small, append=append, prepend=prepend, image=image, text=text)

def addDisplayButtonEx(paneClass, where, text="Display in VTT"):
    callback = def():
        displayPanel(paneClass)
    addDisplayButton(callback, where, text)

lastItemName = ""
lastSpellName = ""
lastSpellLevel = ""
def injectRollButton(paneClass):
    nonlocal settings
    if paneClass in ["ct-custom-skill-pane",
                     "ct-skill-pane",
                     "ct-ability-pane",
                     "ct-ability-saving-throws-pane",
                     "ct-initiative-pane"]:
        if isRollButtonAdded():
            return
        addRollButtonEx(paneClass, ".ct-sidebar__heading")
    elif paneClass in ["ct-class-feature-pane", "ct-racial-trait-pane", "ct-feat-pane"]:
        if isRollButtonAdded():
            return
        addRollButtonEx(paneClass, ".ct-sidebar__heading", text="Display in VTT", image=False)
        name = $(".ct-sidebar__heading").text()
        checkAndInjectDiceToRolls(".ct-snippet__content", name)
    elif paneClass == "ct-trait-pane":
        if isRollButtonAdded():
            return
        addRollButtonEx(paneClass, ".ct-trait-pane__content", text="Display in VTT", image=False)
    elif paneClass == "ct-item-pane":
        nonlocal lastItemName
        item_name = $(".ct-item-pane .ct-item-name").text()
        if isRollButtonAdded() and item_name == lastItemName:
            return
        lastItemName = item_name
        removeRollButtons()

        checkAndInjectDiceToRolls(".ct-item-detail__description", item_name)
        properties = propertyListToDict($(".ct-item-pane .ct-property-list .ct-property-list__property"))
        if "Damage" in properties:
            addRollButtonEx(paneClass, ".ct-sidebar__heading", small=True)
            addDisplayButtonEx(paneClass, ".ct-beyond20-roll")
        else:
            addRollButtonEx(paneClass, ".ct-sidebar__heading", image=False)
            addRollButtonEx(paneClass, ".ct-item-detail__actions", small=True, append=True, image=False)
    elif paneClass in ["ct-action-pane", "ct-custom-action-pane"]:
        if isRollButtonAdded():
            return
            
        properties = propertyListToDict($("." + paneClass + " .ct-property-list .ct-property-list__property"))
        action_name = $(".ct-sidebar__heading").text()
        action_parent = $(".ct-sidebar__header-parent").text()
        if (action_name == "Superiority Dice" or action_parent == "Maneuvers") or \
            (action_name == "Bardic Inspiration" or action_parent == "Blade Flourish") or \
            ("Damage" in properties or properties["To Hit"]? or properties["Attack/Save"]?):
            addRollButtonEx(paneClass, ".ct-sidebar__heading", small=True)
            addDisplayButtonEx(paneClass, ".ct-beyond20-roll")
        else:
            addRollButtonEx(paneClass, ".ct-sidebar__heading")
        checkAndInjectDiceToRolls(".ct-action-detail__description", action_name)
    elif paneClass == "ct-spell-pane":
        nonlocal lastSpellName
        nonlocal lastSpellLevel
        spell_name = $(".ct-sidebar__heading .ct-spell-name")[0].firstChild.textContent
        spell_full_name = $(".ct-sidebar__heading .ct-spell-name").text()
        spell_level = $(".ct-spell-caster__casting-level-current").text()
        if isRollButtonAdded() and spell_full_name == lastSpellName and spell_level == lastSpellLevel:
            return
        lastSpellName = spell_full_name
        lastSpellLevel = spell_level
        removeRollButtons()
        checkAndInjectDiceToRolls(".ct-spell-pane .ct-spell-detail__description", spell_name)

        damages = $(".ct-spell-pane .ct-spell-caster__modifiers--damages .ct-spell-caster__modifier")
        healings = $(".ct-spell-pane .ct-spell-caster__modifiers--healing .ct-spell-caster__modifier")
        properties = propertyListToDict($(".ct-spell-pane .ct-property-list .ct-property-list__property"))
        to_hit = properties["To Hit"] ? \
            findToHit(spell_full_name, ".ct-combat-attack--spell", ".ct-spell-name", ".ct-combat-attack__tohit")
        if not to_hit:
            to_hit = findToHit(spell_full_name, ".ct-spells-spell", ".ct-spell-name", ".ct-spells-spell__tohit")

        if damages.length > 0 or healings.length > 0 or to_hit != None:
            addRollButtonEx(paneClass, ".ct-sidebar__heading", text="Cast on VTT", small=True)
            addDisplayButtonEx(paneClass, ".ct-beyond20-roll")
        else:
            addRollButtonEx(paneClass, ".ct-sidebar__heading", text="Cast on VTT", image=False)

        if spell_name == "Animate Objects":
            nonlocal character
            makeCB = def(size, to_hit, dmg):
                props = buildAttackRoll(character,
                                          "action",
                                          spell_name + "(" + size + ")",
                                          size + " animated object",
                                          {},
                                          [dmg],
                                          ["Bludgeoning"], to_hit)
                return def():
                    sendRollWithCharacter("attack", "1d20" + to_hit, props)
            rows = $(".ct-spell-detail__description table tbody tr")
            for row in rows:
                size = $(row).find("td").eq(0)
                desc = $(row).find("td").eq(5)
                
                m = re.search("(\+[0-9]+) to hit, ([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)) damage", desc.text())
                if m:
                    to_hit = m.group(1)
                    dmg = m.group(2)
                    console.log("Match for ", size, " : ", to_hit, dmg)
                    
                    id = addRollButton(character, makeCB(size.text(), to_hit, dmg), size,
                                        small=True, append=True, image=False, text="Attack")
                    $("#" + id).css({"float": "", "text-align": ""})

        $(".ct-spell-caster__casting-action > button").on('click', def(event):
            execute(paneClass)
        )
    elif paneClass == "ct-reset-pane":
        hitdice = $(".ct-reset-pane__hitdie")
        if hitdice.length > 0:
            if isHitDieButtonAdded():
                return
            removeRollButtons()
            addHitDieButtons(rollHitDie)
        else:
            removeRollButtons()
    elif paneClass == "ct-health-manage-pane":
        if $(".ct-health-manage-pane .ct-health-manager__deathsaves").length > 0:
            if isRollButtonAdded():
                return
            cb = def():
                sendRollWithCharacter("death-save", "1d20", {"advantage": RollType.NORMAL})
            addIconButton(cb, ".ct-health-manager__deathsaves-group--fails")
        else:
            removeRollButtons()
    elif paneClass == "ct-creature-pane":
        nonlocal creature
        if isRollButtonAdded() or isCustomRollIconsAdded():
            if creature:
                creature.updateInfo()
            return
        creature = Monster("Creature", global_settings=settings)
        creature.parseStatBlock()
        creature.updateInfo()
    elif paneClass == "ct-vehicle-pane":
        if isRollButtonAdded() or isCustomRollIconsAdded():
            return
        monster = Monster("Extra-Vehicle", ".ct-vehicle-block", global_settings=settings)
        monster.parseStatBlock()
    elif paneClass == "ct-condition-manage-pane":
        nonlocal character

        j_conditions = $(".ct-condition-manage-pane .ct-toggle-field--enabled").closest(".ct-condition-manage-pane__condition")
        exhaustion_level = $(".ct-condition-manage-pane__condition--special .ct-number-bar__option--active").text()
        conditions = []
        for cond in j_conditions:
            conditions.append(cond.textContent)
        if exhaustion_level == "":
            exhaustion_level = 0
        else:
            exhaustion_level = parseInt(exhaustion_level)

        character.updateConditions(conditions, exhaustion_level)
    else:
        removeRollButtons()


def injectRollToSpellAttack():
    groups = $(".ct-spells-level-casting__info-group")

    for group in groups:
        label = $(group).find(".ct-spells-level-casting__info-label")
        if label.text() == "Spell Attack":
            if label.hasClass("beyond20-rolls-added"):
                return
            label.addClass("beyond20-rolls-added")
            icon16 = chrome.extension.getURL("images/icons/icon16.png")
            items = $(group).find(".ct-spells-level-casting__info-item")
            for item in items:
                modifier = item.textContent
                name = "Spell Attack"
                if items.length > 1:
                    name += "(" + item.getAttribute("data-original-title") + ")"
                img = E.img(class_="ct-beyond20-spell-attack-icon ct-beyond20-spell-attack",
                            x_beyond20_name=name, x_beyond20_modifier=modifier, src=icon16)
                item.append(img)
            $(".ct-beyond20-spell-attack-icon").css("margin-left", "3px")
            $(".ct-beyond20-spell-attack").on('click', def(event):
                name = $(event.currentTarget).attr("x-beyond20-name")
                mod = $(event.currentTarget).attr("x-beyond20-modifier")
                sendRollWithCharacter("custom", "1d20" + mod, {"name": name, "modifier": "1d20" + mod})
            )

def injectSettingsButton():
    if $(".ct-beyond20-settings").length > 0:
        return
    desktop_gap = $(".ct-character-header-desktop__group--gap")
    tablet_gap = $(".ct-character-header-tablet__group--gap")
    mobile_gap = $(".ct-character-header-mobile__group--gap")

    if desktop_gap.length > 0:
        button_type = "desktop"
        gap = desktop_gap
        span_text = "Beyond 20"
        icon = chrome.extension.getURL("images/icons/icon16.png")
    elif tablet_gap.length > 0:
        button_type = "tablet"
        gap = tablet_gap
        span_text = "Beyond 20"
        icon = chrome.extension.getURL("images/icons/icon16.png")
    elif mobile_gap.length > 0:
        button_type = "mobile"
        gap = mobile_gap
        span_text = "\u00A0\u00A0" # Add 2 non breaking spaces as padding
        icon = chrome.extension.getURL("images/icons/icon32.png")
    else:
        return
    button = E.div(class_="ct-character-header-" + button_type + "__group ct-character-header-" + button_type + "__group--beyond20",
                    E.div(class_="ct-character-header-" + button_type + "__button",
                            E.img(class_="ct-beyond20-settings", src=icon),
                            E.span(class_="ct-character-header-" + button_type + "__button-label", span_text)
                    )
    )
    gap.after(button)
    $(button).on('click', def(event): alertQuickSettings();)

quick_roll = False
quick_roll_timeout = 0

def deactivateTooltipListeners(el):
    return el.off('mouseenter').off('mouseleave').off('click')

def activateTooltipListeners(el, tooltip, callback):
    setPosition = def(e):
        tooltip.css({"left": e.pageX - tooltip.width() / 2, "top": e.pageY - tooltip.height() - 5})
    el.on('mouseenter', def(e):
        setPosition(e)
        tooltip.show()
    ).on('mouseleave', def(e):
        tooltip.hide()
    ).on('mousemove', def(e):
        setPosition(e)
    ).on('click', def(e):
        callback(el)
    )

def deactivateQuickRolls():
    abilities = $(".ct-ability-summary .ct-ability-summary__secondary")
    saving_throws = $(".ct-saving-throws-summary__ability .ct-saving-throws-summary__ability-modifier")
    skills = $(".ct-skills .ct-skills__col--modifier")
    actions = $(".ct-combat-attack .ct-combat-attack__icon")
    spells = $(".ct-spells-spell .ct-spells-spell__action")
    deactivateTooltipListeners(abilities)
    deactivateTooltipListeners(saving_throws)
    deactivateTooltipListeners(skills)
    deactivateTooltipListeners(actions)
    deactivateTooltipListeners(spells)
    return (abilities, saving_throws, skills, actions, spells)

def activateQuickRolls():
    nonlocal settings, quick_roll, character
    if quick_roll:
        # quick rolling, don't mess up our tooltip
        return
    beyond20_tooltip = $(".beyond20-quick-roll-tooltip")
    if beyond20_tooltip.length == 0:
        img = E.img(class_="beyond20-quick-roll-icon", src=chrome.extension.getURL("images/icons/icon32.png"), style="margin-right: 5px;margin-left: 5px;padding: 5px 10px;")
        div = E.div(class_="beyond20-quick-roll-tooltip " + getRollTypeButtonClass(character), img)
        beyond20_tooltip = $(div)
        beyond20_tooltip.css({"position": "absolute",
                                "background": 'url("https://www.dndbeyond.com/Content/Skins/Waterdeep/images/character-sheet/content-frames/inspiration.svg") 50% center no-repeat transparent',
                                "background-size": "contain"})
        beyond20_tooltip.hide()
        $("body").append(beyond20_tooltip)
    
    abilities, saving_throws, skills, actions, spells = deactivateQuickRolls()

    if not settings["quick-rolls"]:
        return

    for ability in abilities:
        quickRollAbility = def(el):
            nonlocal quick_roll
            name = el.closest(".ct-ability-summary").find(".ct-ability-summary__heading .ct-ability-summary__label").text()
            # If same item, clicking will be a noop and it won't modify the document
            pane_name = $(".ct-ability-pane .ct-sidebar__heading").text().split(" ")[0]
            if name == pane_name:
                execute("ct-ability-pane")
            else:
                quick_roll = True
        activateTooltipListeners($(ability), beyond20_tooltip, quickRollAbility)

    for save in saving_throws:
        quickRollSave = def(el):
            nonlocal quick_roll
            name = el.closest(".ct-saving-throws-summary__ability").find(".ct-saving-throws-summary__ability-name").text()[0:3].toLowerCase()
            # If same spell, clicking will be a noop and it won't modify it
            pane_name = $(".ct-ability-saving-throws-pane .ct-sidebar__heading").text()[0:3].toLowerCase()
            if name == pane_name:
                execute("ct-ability-saving-throws-pane")
            else:
                quick_roll = True
        activateTooltipListeners($(save), beyond20_tooltip, quickRollSave)

    for skill in skills:
        quickRollSkill = def(el):
            nonlocal quick_roll
            name = el.closest(".ct-skills__item").find(".ct-skills__col--skill").text()
            # If same skill, clicking will be a noop and it won't modify the document
            for paneClass in ["ct-skill-pane", "ct-custom-skill-pane"]:
                pane = $("." + paneClass)
                if pane.length > 0:
                    break
            pane_name = pane.find(".ct-sidebar__heading ." + paneClass + "__header-name").text()

            if name == pane_name:
                execute(paneClass)
            else:
                quick_roll = True
        activateTooltipListeners($(skill), beyond20_tooltip, quickRollSkill)

    for action in actions:
        quickRollAction = def(el):
            nonlocal quick_roll
            name = el.closest(".ct-combat-attack").find(".ct-combat-attack__name .ct-combat-attack__label").text()
            # Need to check all types of panes to find the right one
            for paneClass in ["ct-item-pane", "ct-action-pane", "ct-custom-action-pane", "ct-spell-pane"]:
                pane = $("." + paneClass)
                if pane.length > 0:
                    break
            pane_name = pane.find(".ct-sidebar__heading").text()

            if name == pane_name:
                execute(paneClass)
            else:
                quick_roll = True
        activateTooltipListeners($(action), beyond20_tooltip, quickRollAction)

    for spell in spells:
        quickRollSpell = def(el):
            nonlocal quick_roll
            name = el.closest(".ct-spells-spell").find(".ct-spell-name").text()
            # If same item, clicking will be a noop and it won't modify the document
            pane_name = $(".ct-spell-pane .ct-sidebar__heading .ct-spell-name").text()
            if name == pane_name:
                execute("ct-spell-pane")
            else:
                quick_roll = True
        activateTooltipListeners($(spell), beyond20_tooltip, quickRollSpell)

def executeQuickRoll(paneClass):
    nonlocal quick_roll, quick_roll_timeout
    quick_roll_timeout = 0
    console.log("EXECUTING QUICK ROLL!")
    execute(paneClass)
    quick_roll = False

def documentModified(mutations, observer):
    nonlocal character, quick_roll, quick_roll_timeout

    if isExtensionDisconnected():
        deactivateQuickRolls()
        observer.disconnect()
        return

    character.updateInfo()
    injectRollToSpellAttack()
    injectSettingsButton()
    activateQuickRolls()

    pane = $(".ct-sidebar__pane-content > div")
    if pane.length > 0:
        for div in range(pane.length):
            paneClass = pane[div].className
            if paneClass == "ct-sidebar__pane-controls" or paneClass == "ct-beyond20-settings-pane":
                continue
            console.log("Beyond20: New side panel is : " + paneClass)
            injectRollButton(paneClass)
            if quick_roll:
                if quick_roll_timeout > 0:
                    clearTimeout(quick_roll_timeout)
                quick_roll_timeout = setTimeout(def(): executeQuickRoll(paneClass);, 50)

def updateSettings(new_settings=None):
    nonlocal settings
    nonlocal character

    if new_settings:
        settings = new_settings
        character.setGlobalSettings(settings)
    else:
        getStoredSettings(def(saved_settings):
            nonlocal settings
            updateSettings(saved_settings)
            documentModified()
        )

def handleMessage (request, sender, sendResponse):
    nonlocal settings
    nonlocal character
    console.log("Got message : " + str(request))
    if request.action == "settings":
        if request.type == "general":
            updateSettings(request.settings)
        elif request.type == "character" and request.id == character._id:
            character.updateSettings(request.settings)
        else:
            console.log("Ignoring character settings, not for ID: ", character._id)
    elif request.action == "get-character":
        character.updateInfo()
        sendResponse(character.getDict())
    elif request.action == "open-options":
        alertFullSettings()

injectCSS(ROLLTYPE_STYLE_CSS)
settings = getDefaultSettings()
character = Character(settings)
creature = None
updateSettings()
chrome.runtime.onMessage.addListener(handleMessage)
observer = new window.MutationObserver(documentModified)
observer.observe(document, {"subtree": True, "childList": True})
chrome.runtime.sendMessage({"action": "activate-icon"})

